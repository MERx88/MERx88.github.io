---
layout: default
title: 💎 Solidity
parent: Blockchain
nav_order: 6
---

# 💎 Solidity

## 2024_10_15

### 솔리디티 유용한 링크들

**솔리디티 컨트랙트 스타일 가이드** : https://docs.soliditylang.org/en/v0.8.4/style-guide.html

**스마트 컨트랙트 디자인** : https://medium.com/@solidity101/%EF%B8%8F-smart-contract-design-in-solidity-54b95f72b5c

**6551** : https://eips.ethereum.org/EIPS/eip-6551

## 2024_11_27

### 솔리디티 라이브러리

**특징**

- 변수 선언 불가능
- 이더 송수신 불가능

**왜 씀?**

말그대로 라이브러리 이다. 작성된 코드를 도서관 책꺼내듯이 사용하는 라이브러리 조금 더 특징적인걸 설명하자면

`잘짜여진 코드 사용가능하다`
가스비가 컨트랙트에서 중요한데 내가 고민할필요없이 효율적인 코드를 사용할수있다 그외에 당연한거지만 언급하면 오류 발생률이 낮아지고 안정성, 보안성 시간 절약등이 있다.

## 2024_11_30

### Understanding Storage

Node Guardians
{: .label .label-blue }

솔리디티의 스토리지에 대해 아라보장

**변수는 저장소에 어떻게 할당이 될까?**

우리는 흔히 로우레벨 언어를 사용하다보면 변수를 메모리에 할당한다.

솔리디티도 마찬가지인데 다른점은 효울적으로 스토리지를 관리하기 위해 슬롯이라는 개념이 존재한다. 각 슬롯은 256비트로 이루어져있다.

![alt text](image-5.png)

1. x가 16바이트로 선언이되면 128비트 이기 때문에 반을 차지한다.
2. y는 8바이트이기 때문에 64비트 총 슬롯의 1/4를 차지한다.
3. z는 16바이트이기 때문에 128비트를 차지해야한다 하지만 슬롯 0에는 자리가 없으므로 다음 슬롯에 배정된다.

정말 단순하다 하지만 이러한 개념을 잘모른다면 메모리 누수가 생길수 있을것이다. 그렇기 때문에 슬롯의 빈공간이 없이 최대한 활용해서 할당하는것이 컨트랙트 설계할때 중요하게 작용할것이다.

**매핑은 변수를 어떻게 저장소에 할당할까?**

간단한 변수는 크기에 따라 할당되는 순서와 크기에 따라 다음 슬롯을 사용하기도 사용안하기도 하면서 저장하는 것을 확인했다

그렇다면 매핑은? 다음예시를 보자

![alt text](image-7.png)

변수는 이전에 살펴보았으니 매핑을 집중적으로 살펴보면 우선 map 자체는 한 슬롯을 전부 차지한다. 이곳에는 매핑된 데이터가 어디 슬롯에 위치하는지에 대한 정보가 적혀있다.

위치는 다음과 같이 계산된다. `keccak256(key || i)` i는 매핑 슬롯 자체의 번호를 의미하고 key는 매핑 된 키를 의미한다.

말이 어렵지만 그림을 보면서 살펴보면 map은 슬롯1에 위치하고 있기 땨문에 i=1이다. 만약 map[10]을 찾고 싶다면 key는 10이 된다. 그러면 `keccak256(key || i)`는 `keccak256(10 || 1)`이 되고 이해시값이 실제 값이 저장되어있는 슬롯의 위치가 된다.

> 나는 위치정보자체가 슬롯 1 map에 저장되는 줄알았는데 그게 아니라 단순이 1이라는 숫자만 필요하고 이숫자랑 키값만 사용해서 위치를 찾는거였다 진짜 슬롯 숫자만 필요하다 (솔직히 어이없었다. 왜냐면 뭔가 통째로 슬롯의 공간을 버리는 느낌이 들어서...)

일차원 매핑만 보았다. 그렇다면 이중 매핑은 어떻게 될까?

![alt text](image-9.png)

일차원 매핑을 이해했다면 어렵지 않은 내용이다. 우선 일차원 매핑에서 주소의 위치를 찾았던것처럼 `keccak256(key || i)`를 사용하면 두번째 매핑이 되어있는 슬롯의 위치를 찾아갈수있다. 여기서 한번더 `keccak256(key || i)`를 사용한다면 내가원하는 값을 찾아갈수있을것이다.

**동적배열은 변수를 어떻게 저장소에 할당할까?**

앞서 우리는 매핑이 어떻게 스토리지에 할당되는지 살펴보았다. 매핑자체의 슬롯과 키값을 가지고 해시화를 한 주소에 값을 적어넣는다는것을 알수있었다. 그렇기 때문에 모든 값들이 파편화 되어 저장된다. 동적배열은 파편화되지않고 순차적으로 저장되는 것이 특징이다.

![alt text](image-10.png)

동적배열은 키값이 없기때문에 배열의 슬롯 위치하나만을 가지고 해시화를 진행한다. `keccak256(i)` 위 사진은 배열의 슬롯이 1이기 때문에 `keccak256(1)`이 되고 이 저장소가 배열의 첫번째 위치가 될것이다. 그리고 다음부터는 변수저장하는거처럼 배열 요소의 크기에 따라 슬롯을 차지하게된다. 지금 uint128이기 때문에 한슬롯에 2개의 배열요소를 담을수있는 것이다.

만약 uint128 보다 큰 bytes20가 요소의 크기라면? 다음예제를 보자

![alt text](image-11.png)

당연하지만 한 슬롯에 두개의 요소가 들어가지 못한다. 그리고 배열의 시작 주소는 `keccak256(3)`이 될것이다.

그리고 중요한점은 배열의 슬롯에는 배열의 크기가 저장된다는 것이다. 32바이트 슬롯 통째로 사용하여 배열의 크기를 저장한다.

만약 내가 인덱스 9에 어떤 값을 적고 싶다면 당연히 배열의 길이를 10이상으로 만들어주고 할당해야 정상적으로 작동할것이다.
