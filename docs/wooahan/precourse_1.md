---
layout: default
title: 🍎 Precourse Week 1
parent: Wooahan Tech Course
nav_order: 1
---

# 프리코스 1주차

## Table of contents

1.  [2024_10_15](#2024_10_15)
    - [🗃️ 미션 정리](#️-미션-정리)
      - [🎯 목표](#-목표)
      - [과정 및 주의](#과정-및-주의)
      - [과제 진행 요구 사항](#과제-진행-요구-사항)
      - [기능 요구 사항](#기능-요구-사항)
      - [프로그래밍 요구 사항](#프로그래밍-요구-사항)
      - [라이브러리](#라이브러리)
    - [미션 첫 생각의 흐름](#미션-첫-생각의-흐름)
2.  [2024_10_16](#2024_10_16)
    - [📝 기능 목록](#-기능-목록)
3.  [2024_10_17](#2024_10_17)
    - [🛠️ 기능 구현](#️-기능-구현)
      - [🔩 사용자에게 문자열을 입력 받는 기능](#-사용자에게-문자열을-입력-받는-기능)
4.  [2024_10_19](#2024_10_19)
    - [🔩 기본 구분자로 파싱하는 기능](#-기본-구분자로-파싱하는-기능)
    - [🔩 커스텀 구분자로 파싱하는 기능](#-커스텀-구분자로-파싱하는-기능)
      - [⚙️ parseInput()](#️-parseinput)
    - [🔩 추출한 숫자를 더하고 출력하는 기능](#-추출한-숫자를-더하고-출력하는-기능)
5.  [2024_10_20](#2024_10_20)
    - [🔩 잘못된 입력일 경우 "[ERROR]" 메세지 발생 및 종료 하는 기능](#-잘못된-입력일-경우-error-메세지-발생-및-종료-하는-기능)
    - [🔧 여기저기 터지는 버그처리에서 리팩토링 1 (정규표현식 escape)](#-여기저기-터지는-버그처리에서-리팩토링-1-정규표현식-escape)
      - [⚙️ createDelimetersRegExpPattern()](#️-createdelimetersregexppattern)
    - [🔧 여기저기 터지는 버그처리에서 리팩토링 2 (부동소숫점)](#-여기저기-터지는-버그처리에서-리팩토링-2-부동소숫점)
      - [⚙️ addStrNumsArray()](#️-addstrnumsarray)
6.  [최종 과제 소감문](#최종-과제-소감문)

---

## 2024_10_15

### 🗃️ 미션 정리

**🎯 목표**

- 내가 사용하는 언어로 간단한 문제 해결
- 개발 환경 익숙해지기

**과정 및 주의**

- 구현전 기능 목록 작성
- 기능 단위로 커밋
- 제출은 일요일 오후 3시 이후 [제출 하는 방법](https://github.com/woowacourse/woowacourse-docs/tree/main/precourse)

  - 1차 제출 : 깃헙 미션 올리기
  - 2차 제출 : PR링크와 소감문을 [우테코 지원 플랫폼](https://apply.techcourse.co.kr/)에 제출

> _명시된 출력 형식과 다를 경우 0점_

**과제 진행 요구 사항**

- [프리코스 1주차 repo](https://github.com/woowacourse-precourse/javascript-calculator-7) 저장소를 포크하고 클론해서 시작
- README.md에 구현할 기능 목록 정리
- README.md에 정리한 기능 목록 단위로 커밋 하기 [요구하는 커밋 컨벤션](https://gist.github.com/stephenparish/9941e89d80e2bc58a153)
- [과제 진행 가이드](https://github.com/woowacourse/woowacourse-docs/tree/main/precourse)를 통해 자세한 내용 확인

**기능 요구 사항**

> 입력한 문자열에서 숫자를 추출하여 더하는 계산기를 구현한다.

1. (,),(:) 두가지는 기본 구분자다
2. (//), (\n) 두 문자열 사이의 문자는 커스텀 구분자 이를 구분자로 사용하여 문자열 구분
3. 사용자가 잘못된 값을 입력할 경우 "[ERROR]"로 시작하는 메시지와 함께 Error를 발생시킨 후 애플리케이션은 종료

입력

- 구분자와 양수로 구성된 문자열

**프로그래밍 요구 사항**

- Node.js 20.17.0 버전에서 실행 가능해야 한다.
- 프로그램 실행의 시작점은 App.js의 run()이다.
- package.json 파일은 변경할 수 없으며, 제공된 라이브러리와 스타일 라이브러리 이외의 외부 라이브러리는 사용하지 않는다.
- 프로그램 종료 시 process.exit()를 호출하지 않는다.
- 프로그래밍 요구 사항에서 달리 명시하지 않는 한 파일, 패키지 등의 이름을 바꾸거나 이동하지 않는다.
- 자바스크립트 코드 컨벤션을 지키면서 프로그래밍한다. [해당 링크 컨벤션 필수](https://github.com/woowacourse/woowacourse-docs/tree/main/styleguide/javascript)

**라이브러리**

- @woowacourse/mission-utils에서 제공하는 Console API를 사용
- Console.readLineAsync() : 입력
- Console.print() : 출력

---

### 미션 첫 생각의 흐름

**1주차 과제는 무엇을 나에게서 요구하는 걸까??**

- 내가 사용하는 언어로 간단한 문제 해결

  - "너 자바스크립트 좀 쓰냐?"
  - 입력한 문자열에서 숫자를 추출하여 더하는 계산기를 구현한다.
    - "너 문자열 좀 잘 다루냐?"
    - "그럼 배열 메소드는 얼마나 아냐?"
    - "둘다 어느정도 안다고? 그럼 이 기능 구현은 가능하겠네 해봐 그게 위 말들의 증명이니까"
    - "마지막으로 콘솔로 테스트하고 입출력정도는 하겟지"

- 개발 환경 익숙해지기

  - "깃헙과 깃은 잘쓰냐?"
  - "vscode는 쓸줄 알겠지?"
  - "커밋은? 니맘대로 쓰는거 아냐? 컨벤션이라는게 있고 이거 지켜야함"
  - "이 자식 너 js 컨벤션 니맘대로 쓰지? 이 컨벤션 지켜라"

- 그외

  -"요구사항에 맞춰서 하나의 큰기능을 작은 기능으로 나눠 생각하고 정리할수있어?"

쭉 읽으면서 해당 요구사항들이 이렇게 나에게 물어보는 것처럼 느껴졌다.

### 🤔 요구사항 읽다가 궁금해진 나

요구사항에서 궁금한 내용이 세개 정도 있어서 이를 질문 할까 했는데 아래와 같은 문구가 생각났고 이에 맞춰 개인적으로 판단을 해보기로 했다.

> 기능 요구 사항에 기재되지 않은 내용은 스스로 판단하여 구현한다.

**1️⃣ 커스텀 구분자는 한번에 여러문자여도 가능한가?**

예시에는 한 문자로만 커스텀하는 방식이 나와 있었다.

입력 : `//;\n1;2;3`
출력 : `6`

만약 입력의 커스텀 문자가 여러개라면?

입력 : `//#$%\n1#$%2`
출력 : `3` or `ERROR`?

위의 경우하면 출력은 3이어야할까 error여야 할까? 생각을 좀 하다가 test 코드가 있길래 확인해보았다.

```js
describe("문자열 계산기", () => {
  test("커스텀 구분자 사용", async () => {
    const inputs = ["//;\\n1"];
    mockQuestions(inputs);

    const logSpy = getLogSpy();
    const outputs = ["결과 : 1"];

    const app = new App();
    await app.run();

    outputs.forEach((output) => {
      expect(logSpy).toHaveBeenCalledWith(expect.stringContaining(output));
    });
  });

  test("예외 테스트", async () => {
    const inputs = ["-1,2,3"];
    mockQuestions(inputs);

    const app = new App();

    await expect(app.run()).rejects.toThrow("[ERROR]");
  });
});
```

두가지 테스트가 있었고 다음과 같았다

1번 테스트 : 커스텀 구분자를 구분자로 잘 사용하는가?
2번 테스트 : 예외 처리를 잘하는가?

근데 사실 이걸 보고 더 혼란스러워 졌다. \n 로 끝나야하는데 \\n은 뭐야... 역시 구분자는 여러개를 받을수있는건가? 그리고 테스트에서 숫자 두개 받아주면 좋았을텐데....1개만 받아서 결과도 모르겠네...

사용자 관점에서 생각하고 싶었지만 더 중요한건 요구사항에 나와있는 '구분자'의 정의를 찾아보는 것이었다.

구분자 정의 : https://en.wikipedia.org/wiki/Delimiter

구분자는 delimiter 라고 하며 'A delimiter is a sequence of one or more characters for specifying the boundary between separate, independent regions in plain text, mathematical expressions or other data streams.' 에서도 확인 할 수있듯이 '하나 이상의 문자로 구성된 시퀀스' 라고 나와있다.

그래서 결론은 `한번에 여러 커스텀 구분자를 받아 하나이상의 구분자로도 구분 할수있는 기능`을 만들어야겠다고 생각했다.

**2️⃣ 커스텀 구분자를 사용하면 기본 구분자는 사용이 불가능한가?**

만약 입력에 커스텀 문자로도 구분하고 기본 구분자로도 구분하려고 한다면?

입력 : `//;\n1;2,3`
출력 : `6` or `ERROR`?

위의 경우하면 출력은 6이어야할까 error여야 할까? 테스트 코드에도 이에 대한 테스트는 없었다.

그래서 사용자 관점에서 생각해보았다.

사용자 A가 문자열을 직접 입력해서 이 문자열을 계산하는 경우에는 커스텀만 사용하나 기본만 사용하나 문제가 전혀 되지않는다. (바보같은 실수만 하지 않는다면 자기가 무엇을 입력할지 알고 입력하기 때문) 하지만 사용자 B가 사용자 A에게 해당 문자열을 구분자로 구분해서 덧셈 해줘 했을 때 커스텀 구분자외의 기본 구분자'도' 사용되어야 A 입장에서 번거롭지 않다.

그래서 결론은 `커스텀 구분자를 입력했을 때 커스텀 구분자로도 구분하고 기본 구분자로도 구분하는 기능`을 만들어야겠다고 생각했다.

**3️⃣ 커스텀 구분자는 여러개 받을 수있는가?**

만약 입력에 커스텀 문자 여러개를 받아 구분하려고 한다면?

입력 : `//;\n//$\n1;2,3$4`
출력 : `10` or `ERROR`?

의 경우하면 출력은 10이어야할까 error여야 할까? 역시나 테스트 코드에도 이에 대한 테스트는 없었다.

이것도 2번의 경우와 똑같이 사용자 경험 관점에서 생각한다면 구분자를 최대한 많이 지정할수록 어떤 문자열도 구분가능한 재사용 가능 문자열을 만들수 있다.

결론은 `커스텀 구분자는 (//),(\n) 로 감싸여져있는 구분자는 모두 커스텀 구분자로 사용가능한 기능`을 만들어야겠다고 생각했다.

😎 궁금한 점들은 해소 했으니 이제 구현할 기능들을 목록으로 정리해보자

## 2024_10_16

### 📝 기능 목록

`입력한 문자열에서 숫자를 추출하여 더하는 계산기를 구현한다.`

우선 드라이하게 생각해보면 숫자만 뽑아서 더하면 된다. 결국 관건은 숫자만 파싱해서 들고 있어야한다.

큰 기능들을 생각해보면

1. 사용자에게 문자열을 입력 받는 기능

2. 문자열을 파싱해서 숫자를 추출하는 기능

3. 추출한 숫자를 더하고 출력하는 기능

4. 잘못된 입력일 경우 "[ERROR]" 메세지 발생 및 종료 하는 기능

사실 1번 3번 4번 기능은 어렵지 않다. 2번 기능이 이 기능의 정수인거 같다. 좀 더 세분화해서 생각해보자

2. 문자열을 파싱해서 숫자를 추출하는 기능

- 기본 구분자로 파싱하는 기능
- 커스텀 구분자로 파싱하는 기능

너무 간단한 프로그램이라 이정도의 기능만 갖추면 될거같다 최종 기능 목록은 다음과 같다.

1. 사용자에게 문자열을 입력 받는 기능

2. 문자열을 파싱해서 숫자를 추출하는 기능

- 기본 구분자로 파싱하는 기능
- 커스텀 구분자로 파싱하는 기능

3. 추출한 숫자를 더하고 출력하는 기능

4. 잘못된 입력일 경우 "[ERROR]" 메세지 발생 및 종료 하는 기능

이제 세팅 후 진짜 코딩을 진행해보자

## 2024_10_17

### 🛠️ 기능 구현

**🔩 사용자에게 문자열을 입력 받는 기능**

콘솔에서 문자열을 입력 받는건 어렵지 않지만 조건이 있었다.

```
@woowacourse/mission-utils에서 제공하는 Console API를 사용하여 구현해야 한다.
사용자의 값을 입력 및 출력하려면 Console.readLineAsync()와 Console.print()를 활용한다.
```

그렇다면 해당 레포를 찾아가 어떻게 돌아가는지 확인할 필요가 있지않겠는가? 바로 보러갔다.

woowacourse/mission-utils를 전부다 보고 싶었지만 출력 입력과 관련된 Console.js 파일만 우선 살펴보았다.

@woowacourse/mission-utils/src/console.js :
https://github.com/woowacourse-projects/javascript-mission-utils/blob/main/src/console.js

총 세개의 메서드가 포함된 클래스이다.

엄청 자세히는 뜯어볼 필요 없는거 같다. 간단히 살펴보면

출력인 print는 우리가 흔히 쓰는 `console.log();`를 랩핑해두었다 아마 입력과 출력 모두 통일성을 주기 위해서 한번 랩핑한거같다

입력은 두가지 메서드가 있었는데 둘다 readline 모듈을 불러서 인터페이스 객체 만들고 `rl.question()`를 통해 사용자 입력을 받고 있었다 둘의 차이는 콜백 방식이냐 비동기 처리인 promise 방식이냐의 차이이다.

요구사항에서 `Console.readLineAsync()와 Console.print()를 활용한다.`라고 나와있기에 이를 가지고 작성해보면

```js
const userInput = await Console.readLineAsync(
  "덧셈할 문자열을 입력해 주세요.\n"
);
Console.print(userInput);
```

간단하게 입력 및 출력 하는 기능을 만들수있다.

## 2024_10_19

**🔩 기본 구분자로 파싱하는 기능**

이기능은 사실 자바스크립트 메서드중 split이 바로 생각나서 받은 문자열에 split을 정규표현식과 함께 적어주어 ,와 : 로 간단하게 나누는 기능을 만들수 있었다.

`const parsedInput=userInput.split(/[,:]/)`

그런데 한가지 조건이 있었다. 바로 아무 문자열도 받지않았을때의 처리이다. 이것은 잘못된 입력에 대한 처리는 아니기 때문에 처리를 이 기능에서 해주는게 맞겠다고 생각했다.

요구사항예시를 보면 ""을 받으면 0으로 출력해야한다. 그래서 간단하게 userInput이 있는 지 확인하고 처리하는 조건문을 달아주었다. 그리고 이과정에서 스페이스는 빈문자열이라고 인식할까? 생각해서 스페이스를 userInput으로 넣어 주었는데 스페이스도 하나의 문자로 본다는 점을 좀 새롭게 알았다. 이는 나중에 잘못된 입력과 함께 처리해보려한다.

```js
if (userInput) {
  const parsedInput = userInput.split(/[,:]/);
  Console.print(parsedInput);
} else {
  Console.print(0);
}
```

😎 정규 표현식도 이번 기회에 한번 정리했다. [정규표현식 링크](https://merx88.github.io/docs/Javascript/regExp/)

**🔩 커스텀 구분자로 파싱하는 기능**

이 기능을 구현하기 전 사전에 생각했던 아래 세가지 기능을 포함해서 기능을 짜야한다.

`1. 한번에 여러 커스텀 구분자를 받아 하나이상의 구분자로도 구분 할수있는 기능`  
`2. 커스텀 구분자를 입력했을 때 커스텀 구분자로도 구분하고 기본 구분자로도 구분하는 기능`  
`3. 커스텀 구분자는 (//),(\n) 로 감싸여져있는 구분자는 모두 커스텀 구분자로 사용가능한 기능`

기능을 구현하기 전에 든 생각은 "이 기능하나를 구현하려면 꽤나 많은 코드를 작성해야겠네 그러면 함수로 추상화 시키는게 좋겠다" 이전에도 사실 함수로 추상화 시킬 때 항상 하나의 함수는 하나의 일을 하는게 맞다고 생각했다. 왜냐면 모든 기능을 한 함수에 때려 넣을거면 함수는 왜 있는가 재사용성만을 위해서? 아니라고 생각한다. 기능별로 나누고 추상화를 통해 복잡한 코드를 편하게 읽기 위해서다. 그래서 나는 오로지 입력값을 파싱하는 기능에 집중하는 parseInput()으로 빼려고 한다.

`⚙️ parseInput()`

결국 내가 원하는건 사용자가 입력한 문자열을 받으면 숫자만 추출되어있는 배열을 만드는 것이다.

param : userInput
return : parsedInput

로직은 다음과 같은 생각의 흐름이었다.

1. 구분자를 따로 모아놓을 배열이 하나 필요함
2. 커스텀 구분자를 모아야하기 때문에 //~\n 패턴이 앞에 나오니까 계속 잘라서 중간에 구분자만 추출해서 1번에서 말한 배열에 넣고 //~\n 을 날려버리자 그리고 다시 //로 시작하면 또 다시 커스텀 구분자 넣고 날리고 반복하자 -> `3. 커스텀 구분자는 (//),(\n) 로 감싸여져있는 구분자는 모두 커스텀 구분자로 사용가능한 기능` 이 기능 만족을 위해.👍
3. 날려버릴때 스트링은 불변이기에 재할당 해야한다.
4. 기본 구분자 + 추출한 커스텀 구분자 이 두가지로 문자열을 파싱한다.

사실 이 로직은 어렵지 않다. 진짜 내가 모르는건 `정규표현식` 이었다.

> 🤯 참고로 이 정규표현식이 끝까지 괴롭혔다.

커스텀 구분자 없이 (,),(:)를 파싱하는 방법은 `[,:]` 와 같이 `[]`에 넣으면 뭐든지 매치되는구나~ 쉽네~ 그러면 구분자 잘정리해서 `[,:${customDelimeter}]` 하면 검사해주겠지? 하고 기능을 구현했다. (물론 말도 안된다. 뒤에서 보겠지만 이는 매우 귀여운 생각이었다.) -> 처음부터 (,)(:)를 포함시켜 `[,:${customDelimeter}]`커스텀만 추가하려고 함 이는 `1. 한번에 여러 커스텀 구분자를 받아 하나이상의 구분자로도 구분 할수있는 기능` , `2. 커스텀 구분자를 입력했을 때 커스텀 구분자로도 구분하고 기본 구분자로도 구분하는 기능` 두가지 만족을 위해 👍

{ .note-title }

> 새로알게 된 사실
>
> (\n)는 굉장히 특수하다 그래서 앞에 (\)를 하나더 붙여 (\\n)로 바꿔서 활용해야한다.

parseInput() 함수 다 넣는거 비효율적인거 같아서 커밋 링크로 남겨놓았당
[초기 parseInput() 구현 commit](https://github.com/merx88/javascript-calculator-7/commit/9afede0eb2133a84ed477be3e9bde2875d3161db)

구현하면서 느낀건 이번 프리코스에서 물어보는게 하나 더있다는 거였다. "너 정규표현식 알아?" 나의 대답은 "잘 몰라..."였다. 그래서 다른 방법으로 푸는 방법도 생각해보았지만 효율이 너무 떨어지기에 일찌감찌 포기하고 정규표현식과 친해지기로 했다. 허허 그리고 자바스크립트 스트링 메서드들이 정규표현식과 친해서 더더욱 정규표현식과 친해져야겠다 생각했다.

{ .note-title }

> 새로알게 된 사실 2
>
> 빈배열도...true다...!

{ .highlight }

> 상수는 용도가 뭔지 알기 위해서 선언하는게 좋을거같아서 마지막 커밋에 구분자 지정 하는 패턴 2씩 넘기는걸 const PATTERN_OFFSET=2 로 선언해주었다.

**🔩 추출한 숫자를 더하고 출력하는 기능**

이건 사실...reduce 사용하면 너무 뚝딱 풀린다.

```js
const parsedInput = this.parseInput(userInput);
//sum numbers
const output = parsedInput.reduce((acc, cur) => acc + Number(cur), 0);
Console.print(`결과 : ${output}`);
```

## 2024_10_20

**🔩 잘못된 입력일 경우 "[ERROR]" 메세지 발생 및 종료 하는 기능**

이 기능 다 구현하면서 느낀건 UX와 예외를 개선하는건 생각하면 할수록 꼬리에 꼬리를 문다는거다... 왜 이런 이야기 하는지 살펴보자

우선 예외라... 흠,,,우선 어떤 값이 잘못된 값일지 생각해보았다.

1. 숫자로 시작 하지 않을 경우
2. ,: 로 시작하지않을 경우
3. //로 시작 하지않을 경우

- /n 입력값에 포함 되지 않은 경우

4. 커스텀 구분자와 기본 구분자 그 어느 것도 아닌 구분자가 문자열에 포함된 경우
5. 문자열 숫자가 양수가 아닌경우

제일 처음 생각한 예외 상황 5가지 이다. 사실 구현은 어렵지 않은데 위치를 어디 할지 생각했다. 처음에는 입력한 후 바로 5가지 체크해서 에러를 뱉을까도 생각했는데 비효율적이고 함수의 기능을 최대로 사용하지 못한다 생각했다.
그렇게 1번 2번 3번은 입력하자마자 알수있는 값들이라 바로 체크를 진행했고 4번 5번은 한번 파싱해야 알수있는 값들이라
parseInput() 이후애 체크 가능하도록 수정했다.

> 앞에서 보았던 스페이스(공백)로 시작하는 입력값이나, 이루어진 입력값 모두 1,2,3번의 예외로 걸러진다!

근데 생각해보니... 예외는 더 있었다.

6. 커스텀 구분자를 지정하는 패턴을 지키지 않는 경우
7. (.)이 커스텀 구분자로 지정되는 경우

6번은 `//#$\n//,12,3`와 같이 \n이 없어서 //혼자 노는 경우이다. 물론 반대의 경우도 있고 생각보다 여러경우가 있다. 이 경우들이 모두 3번, 4번과 6번 세가지로 예외를 뱉어내기에 걸러낼수있다. 7번은 사실 내가 조건을 못봤다. 양수는 소수도 포함하기에 .은 커스텀 구분자가 되어선 안된다.

이러한 에러처리를 포함한 코드는 아래 링크에서 볼수있다.
[예외 처리 구현 commit](https://github.com/merx88/javascript-calculator-7/commit/0426b1574fdadfc32a11e7146740b886c00487f2)

**🔧 여기저기 터지는 버그처리에서 리팩토링 1 (정규표현식 escape)**

![happy](image.png)

테스트도 잘돌아가고 코드도 문제가 크게 없다고 생각하고 룰루랄라 하고 마지막으로 이것저것 테스트하는데

입력 : `//@#$\n1,2@#$3@4`
출력 : `10`

> 😟 왜 됨?

나의 커스텀 구분자는 `@#$` 이다. 그렇다면 `,`,`:`,`@#$` 세가지 외의 구분자는 허용이 되지않기에 에러를 뱉어야한다. `@` 너 왜 구분자가 되는거냐!

문제는...`[,:${customDelimeter}]` 이놈이였다. 정규표현식... 알고보니 `[]` 안에 쓰는 건 단 한자만 검사한다는 것이다. 그러니 지금 `[,:@#$]` 상태인거고 `@`뿐만아니라 `#`,`$` 이 기호들도 구분자인것이다. 대안을 찾다 나온 방식은 `,|:|@#$` `|` 파이프로 묶어주는거다!

하지만 문제는 또 터졌다. 정규표현식은 이 식 내에서도 쓰는 기호들이있다. 방금 본 `[]`도 같은 기호다. `[]`를 찾으려는데 정규표현식의 기호 하나로 인식되어서 찾을 수없게 되는것이다. 그래서 이런 친구들은 escape 문자인 (\)를 써줘야한다. 그래서 아까도 줄바꿈으로 인식되지않게 하기 위해 "\\n"으로 했던 것이다. 파이프로도 묶어야하고 이스케이프 문자도 붙여줘야하고 이 함수내에서 이 많은 기능들을 하는것은 바람직하지않다. 또 다시 추상화 하기로 했다. 정규표현식 패턴을 만드는 함수를 만들어서 말이다.

`⚙️ createDelimetersRegExpPattern()`

결국 내가 원하는건 구분자들이 들어있는 배열을 받으면 검사가능한 구분자 정규표현식 패턴을 만드는 것이다.

param : delimetersArray
return : delimetersPattern

지금은 map을 활용해 요소를 하나씩 보고 이중에 이스케이프 문자가 포함되어있으면 앞에 "//"를 붙여 구분자로 활용할수있게 바꾼후 다시 배열에 넣어주면 이스케이프 문자가 포함된 구분자들이되고 이를 join으로 묶으면 패턴들을 만들수 있다.

`//[\n//[]\n2[]3[3`가 이제는 이스케이프 문자로 인해 구분되겠지 싶었는데 또 오류가 난다. 알고보니 정규표현식 `,|:|\\[|\\[\\]` 배열에 들어온 순서대로 구분자를 체크하는 것이었다. 그러니 `[]3`은`[`에 걸려서 split이 되고 `]3`으로 파싱되고 이것이 에러를 발생시키는 것이었다. 사실 처음에는 당황스러웠고 어떻게 sort하지? 했지만 자바스크립트 배열 메서드에는 sort()가 있기에 길이 순으로 나열하면 아주 쉽게 이 문제를 해결할수있다.

아래는 날것의 내 테스트들이다...

테스트 케이스

```
부동 소수점 오차 체크 : // \n1 2 2.3,4,5:6.4
음수 체크 : -3,3,-4
음수가 아닌 - 는 구분자로 사용됨 : //-\n1,-3-4--5,6:7
공백도 구분자로 사용 : // \n1 2
커스텀 구분자 패턴은 쓰지만 아무 것도 지정 안했을때 : //\n12,2,3
네스팅 커스텀 구분자 지정 : ////#\n\n1#3
'//'와 '\n' 짝 패턴을 지키지 않음 (\n이 없는 경우*끝까지 없는 경우) : //#$\n//,12,3
'//'와 '\n' 짝 패턴을 지키지 않음 (//이 없는 경우*처음부터 없는 경우) : $\n2,3$4
'//'와 '\n' 짝 패턴을 지키지 않음 (//이 없는 경우_중간부터 없는 경우) : //$\n@#\n2,3$4
'//'와 '\n' 짝 패턴을 지키지 않음 : \n#//1,2,3#4:5
.은 소숫점과 헷갈리기에 커스텀 구분자로 사용 불가능 : //.\n1,2.3,5
중간에 갑자기 커스텀 지정 패턴사용하는 경우 : //@\n1,2,3,4//$\n2$5@3,4
중간에 갑자기 커스텀 지정 패턴사용하는 경우 : 1,2,3//#\n1:3#4
이스케이프 확인 : //!@#$$$$%\n//^^^^^^^^\n1,2,3,4!@#$$$$%2,3,4,5:4:5^^^^^^^^7^^^^^^^^8
괄호 패턴 확인 : //[\n//[]\n1[]2,3[5
같은 구분자 있을때 긴구분자 우선 체크 : //@\n//@#\n2@#3@3
```

**🔧 여기저기 터지는 버그처리에서 리팩토링 2 (부동소숫점)**

말그대로 부동소숫점 오차 때문에 한번더 리팩토링을 진행하게되었다. 부동 소숫점 알고는 있었고 이를 처리해줘야한다는 것도 알고있었지만 순간 예기치 못했다. 하지만 찾았으니 고쳐보자

부동소숫점 오차는 소수끼리 더했을때 1.2+2.3=3.5가 나와야하지만 3.500000000003 이런식으로 약간 씩의 오차가 생기는 것을 말한다. 왜 생길까? 이에 대해선 아래 링크를 참고하자!

[부동소숫점](https://merx88.github.io/docs/Javascript/mechanism/#%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85)

이를 해결하려면 결국 3.500000000003 에서 00000000003 부분을 버림해야하는거다. 단순히 toFixed나 round floor등으로 수정하면 된다고 생각하지만 어디까지 살려야하는지 명확한 기준을 알려줘야한다.

역시 이러한 과정을 App 안에서 하는건 무리가 있기에 함수로 빼주자

`⚙️ addStrNumsArray()`

결국 내가 원하는건 문자열 숫자로 이루어진 배열을 받고 부동소숫점 오차 없이 더한 값을 리턴하는 것이다.

param : strNumsArray
return : result

아까도 말했지만 부동소숫점을 제거하고 어디까지 디스플레이 할지가 중요하다. 그렇기에 가장 소수부분이 긴 애를 찾아서 이친구를 기준으로 더해진값에 toFixed를 쓴다면 문제는 해결될것이다. 그리고 마지막에는 꼭 Number로 형변환을 진행해서 3.45000 으로 잘린걸 3.45로 변환 시켜줘야 더 보기 좋을것이다.

크게 어렵지 않게 해결했다 😆

해당 코드는 아래 링크를 타고 들어가면 확인할수있다.
[addStrNumsArray() 구현 커밋](https://github.com/woowacourse-precourse/javascript-calculator-7/pull/463/commits/a705b006f3c26e29d3d794823356968371140080)

> 👇 아래는 위글을 토대로 적은 소감문이닷!

# 최종 과제 소감문

> 과제 진행 소감에는 미션을 진행하면서 느끼고 배운 점, 많은 시간을 투자한 부분 등도 포함하면 더 좋을 것 같습니다. 🙂

프리코스 1주차를 진행하며 몇가지 느낀점이 있다.

첫번째는 "생각보다...어렵네?"였다.

과제의 요구사항을 처음에 읽으면서 오 역시 1주차는 워밍업인가? 너무 쉬운데? 지금까지 공부한 String, Array 메소드들만 잘사용하면 적당히 파싱하고 더할수있겠네 라고 생각했다. 하지만 '기능 요구 사항에 기재되지 않은 내용은 스스로 판단하여 구현한다.'라는 말이 이 간단한 문제를 한층 어렵게 만들었다.

요구사항은 생각보다 명확하지 않았다. 이러한 경우도 있을 수있는데 이럴때는 어떻게 하지? 예외로 봐야하나? 아니면 확장성을 위해 기능구현을 더 해야하나? 이러한 의문점들이 생겨나기 시작했고 최대한 요구사항을 지키면서 판단하기로 했다. 총 세가지 의문점이 있었다.

1️. 커스텀 구분자는 한번에 여러문자여도 가능한가?
2️. 커스텀 구분자를 사용하면 기본 구분자는 사용이 불가능한가?
3️. 커스텀 구분자는 여러개 받을 수있는가?

이 의문점을 UX적인 관점, 제시된 요구사항 관점 그리고 정의 를 찾아보며 판단하기 시작했고 결론은 다음과 같았다.

1. 한번에 여러 커스텀 구분자를 받아 하나이상의 구분자로도 구분 할수있는 기능
2. 커스텀 구분자를 입력했을 때 커스텀 구분자로도 구분하고 기본 구분자로도 구분하는 기능
3. 커스텀 구분자는 (//),(\n) 로 감싸여져있는 구분자는 모두 커스텀 구분자로 사용가능한 기능

이 세가지 기능을 포함하는 기능을 구현해야겠다 생각했다. 근데 문제는 이 기능을 포함한 기능구현이 해당 문제의 난이도를 2단계 올려놓은 것 같다.

솔직히 조금 더 쉽게 가기 위해 판단을 바꾸려고도 생각했다. 억지로 내 근거를 바꿔서 말이다. 근데 이 모습은 바람직하지 않은거 같아서 최대한 구현하려고 노력했다. 기능이 더 많아지는 만큼 더 많은 UX를 생각하고 예외를 처리해야해서 수 많은 테스트케이스들이 생겨났고 이 테스트케이스에서 또 수많은 에러와 개선해야할 점들이 생겨났다. 정말 꼬리에 꼬리를 무는 작업들이었다. 여기서 느낀건 간단한 콘솔 프로그램이라도 많은 것들을 고려한다면 쉽지 않은 프로그램이라는 것을 느꼈다. 단순히 기능 구현에만 급급했다면 UX와 에러사항을 간단하게 처리하고 넘어갔을 것이고 이는 개발자 입장에서는 매우 편하지만 UX는 상당히 불편해 질 수 있겠다라는 것을 확인했다.

두번째는 '기능 세분화를 더 해야겠다'였다.

내가 처음 생각한 기능 목록은 너무 간단했다.

기능 목록

1. [✅] 사용자에게 문자열을 입력 받는 기능
2. [✅] 문자열을 파싱해서 숫자를 추출하는 기능
   - [✅] 기본 구분자로 파싱하는 기능
   - [✅] 커스텀 구분자로 파싱하는 기능
3. [✅] 추출한 숫자를 더하고 출력하는 기능
4. [✅] 잘못된 입력일 경우 "[ERROR]" 메세지 발생 및 종료 하는 기능

처음 생각 할때도 물론 에러 부분에서 더 많은 기능들이 추가 될 수도 있겠다 생각했지만 생각보다도 더 많은 기능들이 필요로 했다. 이렇게 늘어나는 기능 목록들을 보며 처음에 적을 때 최대한 생각해서 기능을 세분화해서 적어야겠다라고 생각했다. 왜냐면 더 세세하게 기능 목록을 적고 개발을 한다면 기능과 예외 처리에 대한 테스트케이스들을 미리 생각해볼 수 있고, 큰 태스크도 더 잘 쪼개서 생각하고 해결해나갈 수 있는 힘을 기를 수 있을 것이라 생각했기 때문이다.

세번째는 "아직 프로그래밍 관련 지식들은 모르는게 많고 분명히 공부했던거였는데!" 였다.

몇가지 새로 배운점들과 복습한 부분들이 있었다.

- 새로 배운거

1. 빈 배열도 true로 평가한다.
2. 정규표현식의 이스케이프 문자
3. 커밋 메세지 작성법
4. 에어비앤비 자바스크립트 컨벤션

- 복습한 것들

1. 정규표현식
2. 문자열 메소드와 정규표현식을 잘사용하면 맘대로 조작가능
3. 부동소숫점 오차

이렇게 학습한 부분들은 여러가지를 느끼게 해주었다. 첫번째 자바스크립트는 진짜 예측이 안된다. 예측을 하기위해서 메커니즘을 더 확실히 공부해야겠다. 두번째 정규표현식은 가독성이 떨어지지만 정말 잘만사용한다면 패턴 체크를 나이스하게 할 수 있기에 자주 활용하는 연습을 해야겠다. 세번째 내가 컨벤션을 생각보다 잘지키면서 코드를 작성하고 있었구나 커밋메세지도 형식을 잘지키는구나 앞으로도 해당 형식들을 잘 지키면서 프로그래밍해야겠다. 네번째 계속 까먹을수 있다. 계속 학습하자 였다. 이렇게 네가지를 이번에 프리코스를 하며 느끼고 반성하고 칭찬했다. 특히 네번째 까먹는것은 사람이라면 어쩔 수 없지만 계속해서 기록하여 최대한 기억하려고 한다.

마지막으로 내가 많이 투자한 부분은 어떤 함수라기 보다는 UX, DX 적인 부분이었다. 모든 프로그램은 누군가에게 사용되기 위해 작성된다. 또한 프로그래밍은 혼자하는 작업이 아니다. 그래서 입력을 받을 때에도 요구사항을 지키면서 어떻게 하면 사용자가 더 자유롭게 커스텀 구분자를 사용할 수 있을까? 어떻게 하면 사용자가 자신이 입력한 값이 잘못되었다는 것을 명확히 인지 시켜줄까? 등등을 신경 쓰며 작성했다. 그리고 다른 개발자가 해당 코드를 마주했을 때를 고려하여 변수, 함수 등 작명에 신경썼다. 또한 함수가 한가지 일만 할수 있도록 로직들을 추상화 시키면서 가독성을 높일려고 했다. 물론 더 좋은 작성 방식이 있을 것이지만 내가 할수 있는 한 최대한 UX, DX 를 고려하면서 작성했다. 다음 과제에서도 최소한 지금과 같은 수준으로 UX DX를 최대한 고려하면서 작성하고 싶다. 일종의 다짐이다. 지금은 간단한 문제이기 때문에 이렇게 여러방면을 생각하며 작성할 수 있었지만 앞으로 이렇게 3주를 더하기 어려울 수 있다. 꾸준함이 제일 어려운거 같다. 또한 내가 배운점, 느낀점 그리고 앞으로 있을 코드 리뷰등을 통해 지금보다 더 좋은 코드로 빨리 리팩토링해보고 싶다.

👇 글자수 제한 때문에 적지 못한 더 구체적인 구현과정들을 보고 싶다면? 👇

👀 프리코스 1주차 날것의 언어로 이루어진 여정 기록소: https://merx88.github.io/docs/wooahan/precourse_1/
