---
layout: default
title: 🍎 Precourse Week 1
parent: Wooahan Tech Course
nav_order: 1
---

# 프리코스 1주차

## 2024_10_15

### 🗃️ 미션 정리

**🎯 목표**

- 내가 사용하는 언어로 간단한 문제 해결
- 개발 환경 익숙해지기

**과정 및 주의**

- 구현전 기능 목록 작성
- 기능 단위로 커밋
- 제출은 일요일 오후 3시 이후 [제출 하는 방법](https://github.com/woowacourse/woowacourse-docs/tree/main/precourse)

  - 1차 제출 : 깃헙 미션 올리기
  - 2차 제출 : PR링크와 소감문을 [우테코 지원 플랫폼](https://apply.techcourse.co.kr/)에 제출

> _명시된 출력 형식과 다를 경우 0점_

**과제 진행 요구 사항**

- [프리코스 1주차 repo](https://github.com/woowacourse-precourse/javascript-calculator-7) 저장소를 포크하고 클론해서 시작
- README.md에 구현할 기능 목록 정리
- README.md에 정리한 기능 목록 단위로 커밋 하기 [요구하는 커밋 컨벤션](https://gist.github.com/stephenparish/9941e89d80e2bc58a153)
- [과제 진행 가이드](https://github.com/woowacourse/woowacourse-docs/tree/main/precourse)를 통해 자세한 내용 확인

**기능 요구 사항**

> 입력한 문자열에서 숫자를 추출하여 더하는 계산기를 구현한다.

1. (,),(:) 두가지는 기본 구분자다
2. (//), (\n) 두 문자열 사이의 문자는 커스텀 구분자 이를 구분자로 사용하여 문자열 구분
3. 사용자가 잘못된 값을 입력할 경우 "[ERROR]"로 시작하는 메시지와 함께 Error를 발생시킨 후 애플리케이션은 종료

입력

- 구분자와 양수로 구성된 문자열

**프로그래밍 요구 사항**

- Node.js 20.17.0 버전에서 실행 가능해야 한다.
- 프로그램 실행의 시작점은 App.js의 run()이다.
- package.json 파일은 변경할 수 없으며, 제공된 라이브러리와 스타일 라이브러리 이외의 외부 라이브러리는 사용하지 않는다.
- 프로그램 종료 시 process.exit()를 호출하지 않는다.
- 프로그래밍 요구 사항에서 달리 명시하지 않는 한 파일, 패키지 등의 이름을 바꾸거나 이동하지 않는다.
- 자바스크립트 코드 컨벤션을 지키면서 프로그래밍한다. [해당 링크 컨벤션 필수](https://github.com/woowacourse/woowacourse-docs/tree/main/styleguide/javascript)

**라이브러리**

- @woowacourse/mission-utils에서 제공하는 Console API를 사용
- Console.readLineAsync() : 입력
- Console.print() : 출력

---

<!--
### 미션 첫 생각의 흐름

**1주차 과제는 무엇을 나에게서 요구하는 걸까??**

- 내가 사용하는 언어로 간단한 문제 해결

  - "너 자바스크립트 좀 쓰냐?"
  - 입력한 문자열에서 숫자를 추출하여 더하는 계산기를 구현한다.
    - "너 문자열 좀 잘 다루냐?"
    - "그럼 배열 메소드는 얼마나 아냐?"
    - "둘다 어느정도 안다고? 그럼 이 기능 구현은 가능하겠네 해봐 그게 위 말들의 증명이니까"
    - "마지막으로 콘솔로 테스트하고 입출력정도는 하겟지"

- 개발 환경 익숙해지기

  - "깃헙과 깃은 잘쓰냐?"
  - "vscode는 쓸줄 알겠지?"
  - "커밋은? 니맘대로 쓰는거 아냐? 컨벤션이라는게 있고 이거 지켜야함"
  - "이 자식 너 js 컨벤션 니맘대로 쓰지? 이 컨벤션 지켜라"

- 그외

  -"요구사항에 맞춰서 하나의 큰기능을 작은 기능으로 나눠 생각하고 정리할수있어?"

쭉 읽으면서 해당 요구사항들이 이렇게 나에게 물어보는 것처럼 느껴졌다.

### 🤔 요구사항 읽다가 궁금해진 나

요구사항에서 궁금한 내용이 세개 정도 있어서 이를 질문 할까 했는데 아래와 같은 문구가 생각났고 이에 맞춰 개인적으로 판단을 해보기로 했다.

> 기능 요구 사항에 기재되지 않은 내용은 스스로 판단하여 구현한다.

**1. 커스텀 구분자는 한번에 여러문자여도 가능한가?**

예시에는 한 문자로만 커스텀하는 방식이 나와 있었다.

입력 : `//;\n1;2;3`
출력 : `6`

만약 입력의 커스텀 문자가 여러개라면?

입력 : `//#$%\n1#$%2`
출력 : `3` or `ERROR`?

위의 경우하면 출력은 3이어야할까 error여야 할까? 생각을 좀 하다가 test 코드가 있길래 확인해보았다.

```js
describe("문자열 계산기", () => {
  test("커스텀 구분자 사용", async () => {
    const inputs = ["//;\\n1"];
    mockQuestions(inputs);

    const logSpy = getLogSpy();
    const outputs = ["결과 : 1"];

    const app = new App();
    await app.run();

    outputs.forEach((output) => {
      expect(logSpy).toHaveBeenCalledWith(expect.stringContaining(output));
    });
  });

  test("예외 테스트", async () => {
    const inputs = ["-1,2,3"];
    mockQuestions(inputs);

    const app = new App();

    await expect(app.run()).rejects.toThrow("[ERROR]");
  });
});
```

두가지 테스트가 있었고 다음과 같았다

1번 테스트 : 커스텀 구분자를 구분자로 잘 사용하는가?
2번 테스트 : 예외 처리를 잘하는가?

근데 사실 이걸 보고 더 혼란스러워 졌다. \n 로 끝나야하는데 \\n은 뭐야... 역시 구분자는 여러개를 받을수있는건가? 그리고 테스트에서 숫자 두개 받아주면 좋았을텐데....1개만 받아서 결과도 모르겠네...

사용자 관점에서 생각하고 싶었지만 더 중요한건 요구사항에 나와있는 '구분자'의 정의를 찾아보는 것이었다.

구분자 정의 : https://en.wikipedia.org/wiki/Delimiter

구분자는 delimiter 라고 하며 'A delimiter is a sequence of one or more characters for specifying the boundary between separate, independent regions in plain text, mathematical expressions or other data streams.' 에서도 확인 할 수있듯이 '하나 이상의 문자로 구성된 시퀀스' 라고 나와있다.

그래서 결론은 `한번에 여러 커스텀 구분자를 받아 하나이상의 구분자로도 구분 할수있는 기능`을 만들어야겠다고 생각했다.

**2. 커스텀 구분자를 사용하면 기본 구분자는 사용이 불가능한가?**

만약 입력에 커스텀 문자로도 구분하고 기본 구분자로도 구분하려고 한다면?

입력 : `//;\n1;2,3`
출력 : `6` or `ERROR`?

위의 경우하면 출력은 6이어야할까 error여야 할까? 테스트 코드에도 이에 대한 테스트는 없었다.

그래서 사용자 관점에서 생각해보았다.

사용자 A가 문자열을 직접 입력해서 이 문자열을 계산하는 경우에는 커스텀만 사용하나 기본만 사용하나 문제가 전혀 되지않는다. (바보같은 실수만 하지 않는다면 자기가 무엇을 입력할지 알고 입력하기 때문) 하지만 사용자 B가 사용자 A에게 해당 문자열을 구분자로 구분해서 덧셈 해줘 했을 때 커스텀 구분자외의 기본 구분자 '도' 사용되어야 A 입장에서 번거롭지 않다.

그래서 결론은 `커스텀 구분자를 입력했을 때 커스텀 구분자로도 구분하고 기본 구분자로도 구분하는 기능`을 만들어야겠다고 생각했다.

**3. 커스텀 구분자는 여러개 받을 수있는가?**

만약 입력에 커스텀 문자 여러개를 받아 구분하려고 한다면?

입력 : `//;\n//$\n1;2,3$4`
출력 : `10` or `ERROR`?

의 경우하면 출력은 10이어야할까 error여야 할까? 역시나 테스트 코드에도 이에 대한 테스트는 없었다.

이것도 2번의 경우와 똑같이 사용자 경험 관점에서 생각한다면 구분자를 최대한 많이 지정할수록 어떤 문자열도 구분가능한 재사용 가능 문자열을 만들수 있다.

결론은 `커스텀 구분자는 (//),(\n) 로 감싸여져있는 구분자는 모두 커스텀 구분자로 사용가능한 기능`을 만들어야겠다고 생각했다.

😎 궁금한 점들은 해소 했으니 이제 구현할 기능들을 목록으로 정리해보자

## 2024_10_16

### 📝 기능 목록

`입력한 문자열에서 숫자를 추출하여 더하는 계산기를 구현한다.`

우선 드라이하게 생각해보면 숫자만 뽑아서 더하면 된다. 결국 관건은 숫자만 파싱해서 들고 있어야한다.

큰 기능들을 생각해보면

1. 사용자에게 문자열을 입력 받는 기능

2. 문자열을 파싱해서 숫자를 추출하는 기능

3. 추출한 숫자를 더하고 출력하는 기능

4. 잘못된 입력일 경우 "[ERROR]" 메세지 발생 및 종료 하는 기능

사실 1번 3번 4번 기능은 어렵지 않다. 2번 기능이 이 기능의 정수인거 같다. 좀 더 세분화해서 생각해보자

2. 문자열을 파싱해서 숫자를 추출하는 기능

- 기본 구분자로 파싱하는 기능
- 커스텀 구분자로 파싱하는 기능

너무 간단한 프로그램이라 이정도의 기능만 갖추면 될거같다 최종 기능 목록은 다음과 같다.

1. 사용자에게 문자열을 입력 받는 기능

2. 문자열을 파싱해서 숫자를 추출하는 기능

- 기본 구분자로 파싱하는 기능
- 커스텀 구분자로 파싱하는 기능

3. 추출한 숫자를 더하고 출력하는 기능

4. 잘못된 입력일 경우 "[ERROR]" 메세지 발생 및 종료 하는 기능

이제 세팅 후 진짜 코딩을 진행해보자 -->

## 2024_10_17

### 🛠️ 기능 구현

**사용자에게 문자열을 입력 받는 기능**

콘솔에서 문자열을 입력 받는건 어렵지 않지만 조건이 있었다.

```
@woowacourse/mission-utils에서 제공하는 Console API를 사용하여 구현해야 한다.
사용자의 값을 입력 및 출력하려면 Console.readLineAsync()와 Console.print()를 활용한다.
```

그렇다면 해당 레포를 찾아가 어떻게 돌아가는지 확인할 필요가 있지않겠는가? 바로 보러갔다.

woowacourse/mission-utils를 전부다 보고 싶었지만 출력 입력과 관련된 Console.js 파일만 우선 살펴보았다.

```js
import readline from "readline";

class Console {
  constructor() {}

  static readLine(query, callback) {
    if (arguments.length !== 2) {
      throw new Error("arguments must be 2.");
    }

    if (typeof query !== "string") {
      throw new Error("query must be string");
    }

    if (typeof callback !== "function") {
      throw new Error("callback must be function");
    }

    if (callback.length !== 1) {
      throw new Error("callback must have 1 argument");
    }

    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
    });

    rl.question(query, callback);
  }

  static readLineAsync(query) {
    return new Promise((resolve, reject) => {
      if (arguments.length !== 1) {
        reject(new Error("arguments must be 1"));
      }

      if (typeof query !== "string") {
        reject(new Error("query must be string"));
      }

      const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
      });

      rl.question(query, (input) => {
        rl.close();
        resolve(input);
      });
    });
  }

  static print(message) {
    console.log(message);
  }
}

export default Console;
```

총 세개의 메서드가 포함된 클래스이다.

엄청 자세히는 뜯어볼 필요 없는거 같다. 간단히 살펴보면

출력인 print는 우리가 흔히 쓰는 `console.log();`를 랩핑해두었다 아마 입력과 출력 모두 통일성을 주기 위해서 한번 랩핑한거같다

입력은 두가지 메서드가 있었는데 둘다 readline 모듈을 불러서 인터페이스 객체 만들고 `rl.question()`를 통해 사용자 입력을 받고 있었다 둘의 차이는 콜백 방식이냐 비동기 방식이냐의 차이이다.

요구사항에서 `Console.readLineAsync()와 Console.print()를 활용한다.`라고 나와있기에 이를 가지고 작성해보면

```js
const userInput = await Console.readLineAsync(
  "덧셈할 문자열을 입력해 주세요.\n"
);
Console.print(userInput);
```

간단하게 입력및 출력 하는 기능을 만들수있다.

## 2024_10_19

**기본 구분자로 파싱하는 기능**

이기능은 사실 자바스크립트 메서드중 split이 바로 생각나서 받은 문자열에 split을 정규표현식과 함께 적어주어 ,와 : 로 간단하게 나누는 기능을 만들수 있었다.

`const parsedInput=userInput.split(/[,:]/)`

그런데 한가지 조건이 있었다. 바로 아무 문자열도 받지않았을때의 처리이다. 이것은 잘못된 입력에 대한 처리는 아니기 때문에 처리를 이 기능에서 해주는게 맞겠다고 생각했다.

요구사항예시를 보면 ""을 받으면 0으로 출력해야한다. 그래서 간단하게 userInput이 있는 지 확인하고 처리하는 조건문을 달아주었다. 그리고 이과정에서 스페이스는 빈문자열이라고 인식할까? 생각해서 스페이스를 userInput으로 넣어 주었는데 스페이스도 하나의 문자로 본다는 점을 좀 새롭게 알았다. 이는 나중에 잘못된 입력과 함께 처리해보려한다.

```js
if (userInput) {
  const parsedInput = userInput.split(/[,:]/);
  Console.print(parsedInput);
} else {
  Console.print(0);
}
```

**커스텀 구분자로 파싱하는 기능**

이 기능을 구현하기 전 사전에 생각했던 아래 세가지 기능을 포함해서 기능을 짜야한다.

`1. 한번에 여러 커스텀 구분자를 받아 하나이상의 구분자로도 구분 할수있는 기능`  
`2. 커스텀 구분자를 입력했을 때 커스텀 구분자로도 구분하고 기본 구분자로도 구분하는 기능`  
`3. 커스텀 구분자는 (//),(\n) 로 감싸여져있는 구분자는 모두 커스텀 구분자로 사용가능한 기능`

기능을 구현하기 전에 든 생각은 "이 기능하나를 구현하려면 꽤나 많은 코드를 작성해야겠네 그러면 함수로 추상화 시키는게 좋겠다" 이전에도 사실 함수로 추상화 시킬 때 항상 하나의 함수는 하나의 일을 하는게 맞다고 생각했다. 왜냐면 모든 기능을 한 함수에 때려 넣을거면 함수는 왜 있는가 재사용성만을 위해서? 아니라고 생각한다. 기능별로 나누고 추상화를 통해 복잡한 코드를 편하게 읽기 위해서다. 그래서 나는 오로지 입력값을 파싱하는 기능에 집중하는 parseInput()으로 빼려고 한다.

`parseInput()`

결국 내가 원하는건 사용자가 입력한 문자열을 받으면 숫자만 추출되어있는 배열을 만드는 것이다.

param : userInput
return : parsedInput

로직은 다음과 같은 생각의 흐름이었다.

1. 구분자를 따로 모아놓을 배열이 하나 필요함
2. 커스텀 구분자를 모아야하기 때문에 //~\n 패턴이 앞에 나오니까 계속 잘라서 중간에 구분자만 추출해서 1번에서 말한 배열에 넣고 //~\n 을 날려버리자 그리고 다시 //로 시작하면 또 다시 커스텀 구분자 넣고 날리고 반복하자 -> `3. 커스텀 구분자는 (//),(\n) 로 감싸여져있는 구분자는 모두 커스텀 구분자로 사용가능한 기능` 이 기능 만족을 위해.👍
3. 날려버릴때 스트링은 불변이기에 재할당 해야한다.
4. 기본 구분자 + 추출한 커스텀 구분자 이 두가지로 문자열을 파싱한다.

사실 이 로직은 어렵지 않다. 진짜 내가 모르는건 `정규표현식` 이었다.

> 🤯 참고로 이 정규표현식이 끝까지 괴롭혔다.

커스텀 구분자 없이 (,),(:)를 파싱하는 방법은 `[,:]` 와 같이 `[]`에 넣으면 뭐든지 매치되는구나~ 쉽네~ 그러면 구분자 잘정리해서 `[,:${customDelimeter}]` 하면 검사해주겠지? 하고 기능을 구현했다. (물론 말도 안된다. 뒤에서 보겠지만 이는 매우 귀여운 생각이었다.) -> 처음부터 (,)(:)를 포함시켜 `[,:${customDelimeter}]`커스텀만 추가하려고 함 이는 `1. 한번에 여러 커스텀 구분자를 받아 하나이상의 구분자로도 구분 할수있는 기능` , `2. 커스텀 구분자를 입력했을 때 커스텀 구분자로도 구분하고 기본 구분자로도 구분하는 기능` 두가지 만족을 위해 👍

{ .note-title }

> 새로알게 된 사실
>
> (\n)는 굉장히 특수하다 그래서 앞에 (\)를 하나더 붙여 (\\n)로 바꿔서 활용해야한다.

parseInput() 함수 다 넣는거 비효율적인거 같아서 커밋 링크로 남겨놓았당
[초기 parseInput() 구현 commit](https://github.com/merx88/javascript-calculator-7/commit/9afede0eb2133a84ed477be3e9bde2875d3161db)

구현하면서 느낀건 이번 프리코스에서 물어보는게 하나 더있다는 거였다. "너 정규표현식 알아?" 나의 대답은 "잘 몰라..."였다. 그래서 다른 방법으로 푸는 방법도 생각해보았지만 효율이 너무 떨어지기에 일찌감찌 포기하고 정규표현식과 친해지기로 했다. 허허 그리고 자바스크립트 스트링 메서드들이 정규표현식과 친해서 더더욱 정규표현식과 친해져야겠다 생각했다.

{ .note-title }

> 새로알게 된 사실 2
>
> 빈배열도...true다...!

**추출한 숫자를 더하고 출력하는 기능**

이건 사실...reduce 사용하면 너무 뚝딱 풀린다.

```js
const parsedInput = this.parseInput(userInput);
//sum numbers
const output = parsedInput.reduce((acc, cur) => acc + Number(cur), 0);
Console.print(`결과 : ${output}`);
```

## 2024_10_20

**잘못된 입력일 경우 "[ERROR]" 메세지 발생 및 종료 하는 기능**

이 기능 다 구현하면서 느낀건 UX와 예외를 개선하는건 생각하면 할수록 꼬리에 꼬리를 문다는거다... 왜 이런 이야기 하는지 살펴보자

우선 예외라... 흠,,,우선 어떤 값이 잘못된 값일지 생각해보았다.

1. 숫자로 시작 하지 않을 경우
2. ,: 로 시작하지않을 경우
3. //로 시작 하지않을 경우

- /n 입력값에 포함 되지 않은 경우

4. 커스텀 구분자와 기본 구분자 그 어느 것도 아닌 구분자가 문자열에 포함된 경우
5. 문자열 숫자가 양수가 아닌경우

제일 처음 생각한 예외 상황 5가지 이다. 사실 구현은 어렵지 않은데 위치를 어디 할지 생각했다. 처음에는 입력한 후 바로 5가지 체크해서 에러를 뱉을까도 생각했는데 비효율적이고 함수의 기능을 최대로 사용하지 못한다 생각했다.
그렇게 1번 2번 3번은 입력하자마자 알수있는 값들이라 바로 체크를 진행했고 4번 5번은 한번 파싱해야 알수있는 값들이라
parseInput() 이후애 체크 가능하도록 수정했다. 근데 생각해보니... 예외는 더 있었다.

6. 커스텀 구분자를 지정하는 패턴을 지키지 않는 경우
7. (.)이 커스텀 구분자로 지정되는 경우

6번은 `//#$\n//,12,3`와 같이 \n이 없어서 //혼자 노는 경우이다. 물론 반대의 경우도 있고 생각보다 여러경우가 있다. 이 경우들이 모두 3번, 4번과 6번 세가지로 예외를 뱉어내기에 걸러낼수있다. 7번은 사실 내가 조건을 못봤다. 양수는 소수도 포함하기에 .은 커스텀 구분자가 되어선 안된다.

이러한 에러처리를 포함한 코드는 아래 링크에서 볼수있다.
[예외 처리 구현 commit](https://github.com/merx88/javascript-calculator-7/commit/0426b1574fdadfc32a11e7146740b886c00487f2)

**여기저기 터지는 버그처리에서 리팩토링**

![happy](image.png)

테스트도 잘돌아가고 코드도 문제가 크게 없다고 생각하고 룰루랄라 하고 마지막으로 이것저것 테스트하는데

입력 : `//@#$\n1,2@#$3@4`
출력 : `10`

> 😟 왜 됨?

나의 커스텀 구분자는 `@#$` 이다. 그렇다면 `,`,`:`,`@#$` 세가지 외의 구분자는 허용이 되지않기에 에러를 뱉어야한다. `@` 너 왜 구분자가 되는거냐!

문제는...`[,:${customDelimeter}]` 이놈이였다. 정규표현식... 알고보니 `[]` 안에 쓰는 건 단 한자만 검사한다는 것이다. 그러니 지금 `[,:@#$]` 상태인거고 `@`뿐만아니라 `#`,`$` 이 기호들도 구분자인것이다. 대안을 찾다 나온 방식은 `,|:|@#$` `|` 파이프로 묶어주는거다!

하지만 문제는 또 터졌다. 정규표현식은 이 식 내에서도 쓰는 기호들이있다. 방금 본 `[]`도 같은 기호다. `[]`를 찾으려는데 정규표현식의 기호 하나로 인식되어서 찾을 수없게 되는것이다. 그래서 이런 친구들은 escape 문자인 (\)를 써줘야한다. 그래서 아까도 줄바꿈으로 인식되지않게 하기 위해 "\\n"으로 했던 것이다. 파이프로도 묶어야하고 이스케이프 문자도 붙여줘야하고 이 함수내에서 이 많은 기능들을 하는것은 바람직하지않다. 또 다시 추상화 하기로 했다. 정규표현식 패턴을 만드는 함수를 만들어서 말이다.

`createDelimetersRegExpPattern()`

결국 내가 원하는건 구분자들이 들어있는 배열을 받으면 검사가능한 구분자 정규표현식 패턴을 만드는 것이다.

param : delimetersArray
return : delimetersPattern

로직은 다음과 같은 생각의 흐름이었다.

테스트 케이스

// 부동 소수점 오차 체크 : // \n1 2 2.3,4,5:6.4
// 음수 체크 : -3,3,-4
// 음수가 아닌 - 는 구분자로 사용됨 : //-\n1,-3-4--5,6:7
// 공백도 구분자로 사용 : // \n1 2
// 커스텀 구분자 패턴은 쓰지만 아무 것도 지정 안했을때 : //\n12,2,3
// 네스팅 커스텀 구분자 지정 : ////#\n\n1#3
// '//'와 '\n' 짝 패턴을 지키지 않음 (\n이 없는 경우*끝까지 없는 경우) : //#$\n//,12,3
// '//'와 '\n' 짝 패턴을 지키지 않음 (//이 없는 경우*처음부터 없는 경우) : $\n2,3$4
// '//'와 '\n' 짝 패턴을 지키지 않음 (//이 없는 경우_중간부터 없는 경우) : //$\n@#\n2,3$4
// '//'와 '\n' 짝 패턴을 지키지 않음 : \n#//1,2,3#4:5
// .은 소숫점과 헷갈리기에 커스텀 구분자로 사용 불가능 : //.\n1,2.3,5
// 중간에 갑자기 커스텀 지정 패턴사용하는 경우 : //@\n1,2,3,4//$\n2$5@3,4
// 중간에 갑자기 커스텀 지정 패턴사용하는 경우 : 1,2,3//#\n1:3#4
// 이스케이프 확인 : //!@#$$$$%\n//^^^^^^^^\n1,2,3,4!@#$$$$%2,3,4,5:4:5^^^^^^^^7^^^^^^^^8
// 괄호 패턴 확인 : //[\n//[]\n1[]2,3[5
// 같은 구분자 있을때 긴구분자 우선 체크 : //@\n//@#\n2@#3@3
//패턴을 만드는 일은 다른 함수한테 시켜도 되는거아닌가? 하는 일이 너무 많아

//부동 소수점 오차도 있네....
